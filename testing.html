<!-- $Id: testing.html,v 4d38170bbd56 2005/08/20 05:57:56 simonjwright $ -->
<html>
<head>
<title>ColdFrame: Testing</title>
</head>
<body bgcolor="white">

<table width="100%">
<tr>
<td><font size="+3">ColdFrame: Testing</font>
<td align="right"><a href="http://sourceforge.net"> <img
src="http://sourceforge.net/sflogo.php?group_id=95861&amp;type=5"
width="210" height="62" border="0" alt="SourceForge.net Logo" /></a>
</tr>
</table>

<h2><a href="http://libre.act-europe.fr/aunit/">AUnit</a></h2>

<p>AUnit has the concept <i>test case</i>; for each test case there is
a <i>fixture</i>, which corresponds to the standard setup that each
test procedure in the test case expects.

<p>The fixture is implemented using the test case operations
<tt>Set_Up</tt> and <tt>Tear_Down</tt>.

<p>ColdFrame supports <tt>Set_Up</tt> using its standard
<a href="domains.html#initialize"><tt><i>Domain</i>.Initialize</tt></a> and
<a
href="domains.html#cascade-initialize"><tt>Cascade_Initialize</tt></a>
procedures.

<p>ColdFrame supports <tt>Tear_Down</tt> by providing 
<a href="domains.html#teardown"><tt><i>Domain</i>.Tear_Down</tt></a>
and
<a
href="domains.html#cascade-teardown"><tt>Cascade_Tear_Down</tt></a>
procedures.


<h2><a name="stubs">Stubs</a></h2>

<img src="house-digital-io.png">

<p>Most systems are composed of numerous domains, some of which
provide resources and capabilities to others. In the diagram, the
application-level <a href="House_Management.html"><i>House
Management</i></a> domain uses the services of the device-level <a
href="Digital_IO.html"><i>Digital IO</i></a> domain.

<p>While unit-testing <i>House Management</i>, it's a Bad Idea to use
the real Digital IO, for various reasons:

<ul>

<li>it may only run on target hardware

<li>it may not have been developed yet

<li>it may be hard to make it behave in the way your test plans need

<li>it may be hard to check that you made the correct calls to it

<li>...

</ul>

<p>What is needed is a version of <i>Digital IO</i> which provides the
interfaces of the real thing but with an alternative implementation,
more amenable to testing.

<h3>Separating out the interface</h3>

<p>The first thing to do is to make a child package, <i>Digital IO
Interface</i>, stereotyped &#171;include&#187;. You may like to make
it a separately controlled unit; you might even choose to create it as
part of the development of the using domain, depending on the order of
development.

<p>In this package put all the &#171;public&#187; classes and
&#171;callback&#187; types, any &#171;type&#187; types used by them,
and any &#171;exception&#187;s.

<p><table border='1'>

<tr><td>Complete package<td><img src="digital-io.png">

<tr><td>Interface package<td><img src="digital-io-interface.png">

</table>

<p>In the Interface package, include the tag <tt>{name = Digital
IO}</tt>. This means that if you select the <i>Digital IO
Interface</i> package and generate code from it, code will be
generated as if it were the package <i>Digital IO</i> (though the code
will still be placed in the directory derived from the actual package
name, <tt>Digital_IO_Interface.gen/</tt>).

<i><p>If this domain is not a new development, there may be existing
stub implementations that expect the "Digital IO Interface" name. If
so, you may not be able to use the {name} tag; as an alternative, you
can specify the <tt>DOMAIN_NAME</tt> variable to <tt>make</tt>:</i>

<i><pre>
   $ make Digital_IO_Interface.gen DOMAIN_NAME=Digital_IO
</pre></i>

<i><p>or</i>

<i><pre>
   $ make Digital_IO_Interface.gen DOMAIN_NAME='Digital IO'
</pre></i>

<i><p>The command line method overrides the {name} tag if both are
given.</i>

<i><p><b>Don't</b> set <tt>DOMAIN_NAME</tt> as an environment
variable!</i>

<h3>Implementing stub functionality</h3>

<p>If you want, you can provide implementations in the parallel
<tt>Digital_IO_Interface.impl/</tt> directory, as normal. You'll want
to provide some means of storing <tt>in</tt> parameters and providing
values for <tt>out</tt> parameters and function results; you'll want
to provide queries to find out what values were passed in. Remember
that you can write package specs in the <tt>.impl</tt> directory, if
needed.

<p>You should generate <tt>Digital_IO_Interface.gen/</tt> in
<i>your</i> test directory. The stubs you want probably won't be the
same as other developers also testing code that uses <i>Digital
IO</i>.

<h3>Generating stub functionality</h3>

<p>Normally, ColdFrame generates the separate bodies of operations to
raise <tt>Unimplemented</tt>, and you get to fill in the real code.

<p>If you generate with <tt>GENERATE_STUBS</tt> set to <tt>yes</tt>

<pre>
   $ make Digital_IO_Interface.gen GENERATE_STUBS=yes
</pre>

<p>the separate bodies will contain stub code which

<ol>

<li>stores <tt>in</tt> or <tt>in out</tt> parameters' values for
retrieval

<li>raises an exception, if specified

<li>sets <tt>out</tt> or <tt>in out</tt> parameters or a
function's <tt>return</tt> value as specified.

</ol>

<p>The stub code uses <tt>ColdFrame.Stubs</tt>.

<p>No stub code is generated for protected types or tasks, but since
the intention of the stub support is to implement domain interfaces
this should not be a problem.

<h4>Test Case support</h4>

<p>Your test case <tt>Set_Up</tt> must call
<tt>ColdFrame.Stubs.Set_Up</tt>, and your <tt>Tear_Down</tt> must call
<tt>ColdFrame.Stubs.Tear_Down</tt>.

<p>If the stubbed code has output parameters or returns values of type
<i><tt>T</tt></i>, instantiate
<tt>ColdFrame.Stubs.Set_Output_Value</tt> with <i><tt>T</tt></i>.

<pre>
   --  Specify an output from a call to a stubbed operation for the
   --  type T.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  Normally the named parameter will be an "out" (perhaps "in
   --  out") parameter. The specified "To" value will be returned on
   --  the "For_Call"th call, and all subsequent calls until another
   --  "Set_Output_Value" call for the same parameter; if you want to
   --  have the first 4 calls to Domain.Class.Operation to set Output
   --  to 4, and any later ones to set it to 42, you'd say
   --
   --     Set_Integer_Output_Value ("Domain.Class.Operation", "Output", 4, 1);
   --     Set_Integer_Output_Value ("Domain.Class.Operation", "Output", 42, 5);
   --
   --  A special parameter name is "return". For "return", the To
   --  value will be the function result.
   --
   --  A previously stored value for a particular call can only be
   --  overridden if Override is True (when it must be).
   --
   --  Overhead_Bytes is the additional space reserved for the
   --  streamed representation.
   generic
      type T (<>) is private;
   procedure Set_Output_Value (For_Subprogram_Named : String;
                               For_Parameter_Named : String;
                               To : T;
                               For_Call : Positive := 1;
                               Override : Boolean := False;
                               Overhead_Bytes : Natural := Storage_Overhead);
</pre>

<p>If the stubbed code has input parameters of type <i><tt>T</tt></i>
and you want to check that your code has supplied the right values,
instantiate <tt>ColdFrame.Stubs.Get_Input_Value</tt> with
<i><tt>T</tt></i>.

<pre>
   --  Retrieve values passed to stubbed operations for the type T.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  The named parameter will be an "in" (perhaps "in out")
   --  parameter. To retrieve the result of the second call, you'd say
   --
   --     Result := Get_Integer_Operation_Input_Value
   --       ("Domain.Class.Operation", "Input", 2);
   generic
      type T (<>) is private;
   function Get_Input_Value (For_Subprogram_Named : String;
                             For_Parameter_Named : String;
                             For_Call : Positive := 1) return T;
</pre>

<h4>Test Procedure support</h4>

<p>Call your instantiations of <tt>Set_Output_Value</tt> to set up
the results of calls to stubbed subprograms.

<p>Call <tt>ColdFrame.Stubs.Set_Exception</tt> if you want a stubbed
subprogram to raise an exception.

<pre>
   --  Specify that a call to a stubbed operation is to raise an
   --  exception.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  Normally the exception will be raised for the specified call
   --  and all later calls; to stop this, use Ada.Exceptions.Null_Id.
   --
   --  A previously stored exception for a particular call can only be
   --  overridden if Override is True (when it must be).
   procedure Set_Exception (For_Subprogram_Named : String;
                            E : Ada.Exceptions.Exception_Id;
                            For_Call : Positive := 1;
                            Override : Boolean := False);
</pre>

<p>Call your code as required.

<p>Call <tt>Number_Of_Calls</tt> to find out how often a subprogram
has been called.

<code>
   --  Retrieve the number of calls made to the named subprogram.
   function Number_Of_Calls (For_Subprogram_Named : String) return Natural;
</code>

<p>Call your instantiations of <tt>Get_Input_Value</tt> to retrieve
any parameters input to stubbed subprograms.

<p><hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>
