<!-- $Id: testing.html,v 4c9f5de7edd9 2008/07/13 15:11:14 simonjwright $ -->
<html>
<head>
<title>ColdFrame: Testing</title>
<link href="cf.css" rel="stylesheet" type="text/css"/>
</head>
<body>

<div id="header">
<a
href="http://sourceforge.net"><img
src="http://sourceforge.net/sflogo.php?group_id=135558&amp;type=1"
width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
</div>

<h1>ColdFrame: Testing</h1>

<hr/>

<ul>

<li><a href="#aunit">AUnit</a>

<ul>

<li><a href="#access-to-private">Access to private information</a>

</ul>

<li><a href="#stubs">Stubs</a>

<ul>

<li><a href="#separating">Separating out the interface</a>

<li><a href="#implementing-stub">Implementing stub functionality</a>

<li><a href="#generating-stub">Generating stub functionality</a>

<ul>

<li><a href="#test-case-support">Test Case support</a>

<li><a href="#test-procedure-support">Test Procedure support</a>

<li><a href="#example">Example</a>

</ul>

</ul>
<li><a href="#inspecting-event-queues">Inspecting event queues</a>

</ul>

<hr/>

<h2><a name="aunit"><a href="http://libre.act-europe.fr/aunit/">AUnit</a></a></h2>

<p>AUnit has the concept <i>test case</i>; for each test case there is
a <i>fixture</i>, which corresponds to the standard setup that each
test procedure in the test case expects.

<p>The fixture is implemented using the test case operations
<tt>Set_Up</tt> and <tt>Tear_Down</tt>.

<p>ColdFrame supports <tt>Set_Up</tt> using its standard
<a href="domains.html#initialize"><tt><i>Domain</i>.Initialize</tt></a> (and
<a
href="domains.html#cascade-initialize"><tt>Cascade_Initialize</tt></a>)
procedures.

<p>ColdFrame supports <tt>Tear_Down</tt> by providing 
<a href="domains.html#teardown"><tt><i>Domain</i>.Tear_Down</tt></a>
(and
<a
href="domains.html#cascade-teardown"><tt>Cascade_Tear_Down</tt></a>)
procedures.

<h3><a name="access-to-private">Access to private information</a></h3>

<p>ColdFrame takes a fairly restrictive attitude to the visibility of
constructs in the generated code. For example, only &#171;public&#187;
classes are publicly visible outside the domain; all other classes are
implemented as private children of the domain package, and the full
declaration of a class's instance record is in the private part of the
class's package specification.

<p>If you are doing domain-level "unit" tests (that is, tests that
involve <a href="#stubs">stubbed functionality</a> from other
domains), implement the test suite in a child unit of the domain
(perhaps <tt><i>Domain</i>.Unit_Test</tt>).

<p>There are two approaches to doing class-level unit tests.

<p>The first is similar to that for domain-level tests: implement the
test suite in a child unit of the class (perhaps
<tt><i>Domain.Class</i>.Tests</tt>).

<p>You may feel that this leads to too many deeply-nested packages. As
an alternative, generate the code with the <tt>UNIT_TEST_SUPPORT</tt>
variable set to <tt>yes</tt>:

<pre>
   $ make <i>Domain</i>.gen UNIT_TEST_SUPPORT=yes
</pre>

<p>This generates a child package for each
class, <tt><i>Domain.Class</i>.Unit_Test</tt>, which
contains <tt>Get_</tt> and <tt>Set_</tt> subprograms for each mutable
attribute excluding <i>Timer</i>s and, for a class with a state
machine, <tt>Get_State_Machine_State</tt>
and <tt>Set_State_Machine_State</tt> subprograms.

<p>Identifying attributes are immutable, and only have a <tt>Get_</tt>
operation.

<p><i>Timer</i>s are supported by an <tt>Access_</tt> function
returning an access-to-Timer; you can use
the <a href="#inspecting-event-queues">event queue inspection
facilities</a> to find out more.

<p>What it does <em>not</em> do is allow you to access private
subprograms of the class. A common reason for having private
operations is to implement state machines; in this case, you could
consider <a href="event-use.html#synchronous">calling the event
handler synchronously</a> (just remember to set the state first). It's
arguable that by doing this you have a more representative execution
path, anyway.

<h2><a name="stubs">Stubs</a></h2>

<img src="house-digital-io.png">

<p>Most systems are composed of numerous domains, some of which
provide resources and capabilities to others. In the diagram, the
application-level <a href="House_Management.html"><i>House
Management</i></a> domain uses the services of the device-level <a
href="Digital_IO.html"><i>Digital IO</i></a> domain.

<p>While unit-testing <i>House Management</i>, it's a Bad Idea to use
the real Digital IO, for various reasons:

<ul>

<li>it may only run on target hardware

<li>it may not have been developed yet

<li>it may be hard to make it behave in the way your test plans need

<li>it may be hard to check that you made the correct calls to it

<li>...

</ul>

<p>What is needed is a version of <i>Digital IO</i> which provides the
interfaces of the real thing but with an alternative implementation,
more amenable to testing.

<h3><a name="separating">Separating out the interface</a></h3>

<p>The first thing to do is to make a child package, <i>Digital IO
Interface</i>, stereotyped &#171;include&#187;. You may like to make
it a separately controlled unit; you might even choose to create it as
part of the development of the using domain, depending on the order of
development.

<p>In this package put all the &#171;public&#187; classes and
&#171;callback&#187; types, any &#171;type&#187; types used by them,
and any &#171;exception&#187;s.

<p><table border='1'>

<tr><td>Complete package<td><img src="digital-io.png">

<tr><td>Interface package<td><img src="digital-io-interface.png">

</table>

<p>In the Interface package, include the tag <tt>{name = Digital
IO}</tt>. This means that if you select the <i>Digital IO
Interface</i> package and generate code from it, code will be
generated as if it were the package <i>Digital IO</i> (though the code
will still be placed in the directory derived from the actual package
name, <tt>Digital_IO_Interface.gen/</tt>).

<i><p>If this domain is not a new development, there may be existing
stub implementations that expect the "Digital IO Interface" name. If
so, you may not be able to use the {name} tag; as an alternative, you
can specify the <tt>DOMAIN_NAME</tt> variable to <tt>make</tt>:</i>

<i><pre>
   $ make Digital_IO_Interface.gen DOMAIN_NAME=Digital_IO
</pre></i>

<i><p>or</i>

<i><pre>
   $ make Digital_IO_Interface.gen DOMAIN_NAME='Digital IO'
</pre></i>

<i><p>The command line method overrides the {name} tag if both are
given.</i>

<i><p><b>Don't</b> set <tt>DOMAIN_NAME</tt> as an environment
variable!</i>

<h3><a name="implementing-stub">Implementing stub functionality</a></h3>

<p>If you want, you can provide implementations in the parallel
<tt>Digital_IO_Interface.impl/</tt> directory, as normal. You'll want
to provide some means of storing <tt>in</tt> parameters and providing
values for <tt>out</tt> parameters and function results; you'll want
to provide queries to find out what values were passed in. Remember
that you can write package specs in the <tt>.impl</tt> directory, if
needed.

<p>You should generate <tt>Digital_IO_Interface.gen/</tt> in
<i>your</i> test directory. The stubs you want probably won't be the
same as other developers also testing code that uses <i>Digital
IO</i>.

<h3><a name="generating-stub">Generating stub functionality</a></h3>

<p>Normally, ColdFrame generates the separate bodies of operations to
raise <tt>Unimplemented</tt>, and you get to fill in the real code.

<p>If you generate with <tt>GENERATE_STUBS</tt> set to <tt>yes</tt>

<pre>
   $ make Digital_IO_Interface.gen GENERATE_STUBS=yes
</pre>

<p>the separate bodies will contain stub code which

<ol>

<li>stores <tt>in</tt> or <tt>in out</tt> parameters' values for
retrieval

<li>raises an exception, if specified

<li>sets <tt>out</tt> or <tt>in out</tt> parameters or a
function's <tt>return</tt> value as specified.

</ol>

<p>The stub code uses <tt>ColdFrame.Stubs</tt>.

<p>No stub code is generated for protected types or tasks, but since
the intention of the stub support is to implement domain interfaces
this should not be a problem.

<h4><a name="test-case-support">Test Case support</a></h4>

<p>Your test case <tt>Set_Up</tt> must call
<tt>ColdFrame.Stubs.Set_Up</tt>, and your <tt>Tear_Down</tt> must call
<tt>ColdFrame.Stubs.Tear_Down</tt>.

<p>If the stubbed code has output parameters or returns values of type
<i><tt>T</tt></i>, instantiate
<tt>ColdFrame.Stubs.Set_Output_Value</tt> with <i><tt>T</tt></i>.

<pre>
   --  Specify an output from a call to a stubbed operation for the
   --  type T.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  Normally the named parameter will be an "out" (perhaps "in
   --  out") parameter. The specified "To" value will be returned on
   --  the "For_Call"th call, and all subsequent calls until another
   --  "Set_Output_Value" call for the same parameter; if you want to
   --  have the first 4 calls to Domain.Class.Operation to set Output
   --  to 4, and any later ones to set it to 42, you'd say
   --
   --     Set_Integer_Output_Value ("Domain.Class.Operation", "Output", 4, 1);
   --     Set_Integer_Output_Value ("Domain.Class.Operation", "Output", 42, 5);
   --
   --  A special parameter name is "return". For "return", the To
   --  value will be the function result.
   --
   --  A previously stored value for a particular call can only be
   --  overridden if Override is True (when it must be).
   --
   --  Overhead_Bytes is the additional space reserved for the
   --  streamed representation.
   generic
      type T (<>) is private;
   procedure Set_Output_Value (For_Subprogram_Named : String;
                               For_Parameter_Named : String;
                               To : T;
                               For_Call : Positive := 1;
                               Override : Boolean := False;
                               Overhead_Bytes : Natural := Storage_Overhead);
</pre>

<p>If the stubbed code has input parameters of type <i><tt>T</tt></i>
and you want to check that your code has supplied the right values,
instantiate <tt>ColdFrame.Stubs.Get_Input_Value</tt> with
<i><tt>T</tt></i>.

<pre>
   --  Retrieve values passed to stubbed operations for the type T.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  The named parameter will be an "in" (perhaps "in out")
   --  parameter. To retrieve the result of the second call, you'd say
   --
   --     Result := Get_Integer_Operation_Input_Value
   --       ("Domain.Class.Operation", "Input", 2);
   generic
      type T (<>) is private;
   function Get_Input_Value (For_Subprogram_Named : String;
                             For_Parameter_Named : String;
                             For_Call : Positive := 1) return T;
</pre>

<h4><a name="test-procedure-support">Test Procedure support</a></h4>

<p>Call your instantiations of <tt>Set_Output_Value</tt> to set up the
results of calls to stubbed subprograms. Often, and particularly for
"environmental" operations, this will be in the AUnit test
case's <tt>Set_Up</tt> procedure; in that case, you might want to use
the <tt>Override</tt> parameter to alter your standard setup for a
specific test procedure.

<p>Call <tt>ColdFrame.Stubs.Set_Exception</tt> if you want a stubbed
subprogram to raise an exception (to get an <tt>Exception_Id</tt>, use
<tt><i>exception-name</i>'Identity</tt>).

<pre>
   --  Specify that a call to a stubbed operation is to raise an
   --  exception.
   --
   --  For_Subprogram_Named is the case-insensitive fully-qualified
   --  name of the subprogram (eg, if dealing with procedure
   --  Domain.Class.Operation, "Domain.Class.Operation").
   --
   --  Normally the exception will be raised for the specified call
   --  and all later calls; to stop this, use Ada.Exceptions.Null_Id.
   --
   --  A previously stored exception for a particular call can only be
   --  overridden if Override is True (when it must be).
   procedure Set_Exception (For_Subprogram_Named : String;
                            E : Ada.Exceptions.Exception_Id;
                            For_Call : Positive := 1;
                            Override : Boolean := False);
</pre>

<p>Call your code as required.

<p>Call <tt>Number_Of_Calls</tt> to find out how often a subprogram
has been called.

<pre>
   --  Retrieve the number of calls made to the named subprogram.
   function Number_Of_Calls (For_Subprogram_Named : String) return Natural;
</pre>

<p>Call your instantiations of <tt>Get_Input_Value</tt> to retrieve
any parameters input to stubbed subprograms. You can supply the
value <tt>ColdFrame.Stubs.Last</tt> in the <tt>For_Call</tt> parameter
to retrieve the last value (though usually you should know how many
calls should have been made).

<h4><a name="example">Example</a></h4>

<p>There's an example in the <tt>examples/House_Management.test/</tt>
subdirectory of the source distribution.

<p>Note that the test suite is a child of
the <tt>House_Management</tt> domain. This is so that the test code
has access to private members of the domain (non-&#171;public&#187;
classes and associations, for a start).

<ul>

<li><a href="#main">The main program</a>

<li><a href="#suite-spec">The test suite spec</a>

<li>The test suite body

<ul>

<li><a href="#aunit-withs">Standard AUnit withs</a>

<li><a href="#test-withs">Test-specific withs</a>

<li><a href="#suite-body">The actual body</a>

<ul>

<li><a href="#instantiations">Instantiations of <tt>ColdFrame.Stubs</tt> generics</a>

<li><a href="#case-spec">A test case spec, for testing <i>Lamp</i> code</a>

<li><a href="#case-body">The test case body</a>

<ul>

<li><a href="#proc-spec">A test procedure spec</a>

<li><a href="#proc-body">The test procedure body</a>

<li><a href="#case-name">The test case name</a>

<li><a href="#registration">Test procedure registration</a>

<li><a href="#set-up">The test case set-up</a>

<li><a href="#tear-down">The test case tear-down</a>

</ul>

<li><a href="#end-case">End of test case</a>

</ul>

<li><a href="#suite-function">The test suite function</a>

<li><a href="#end-suite">End of test suite</a>

</ul>

</ul>

<hr/>

<p><a name="main">The main program</a>:
<pre>
   with AUnit.Test_Runner;
   with House_Management.Test_Suite;
   with GNAT.Exception_Traces;

   procedure House_Management.Harness is

      procedure Run is new AUnit.Test_Runner (Test_Suite.Suite);

   begin

      GNAT.Exception_Traces.Trace_On
        (Kind => GNAT.Exception_Traces.Unhandled_Raise);

      Run;

   end House_Management.Harness;
</pre>

<p><a name="suite-spec">The test suite spec</a>:
<pre>
   with AUnit.Test_Suites;

   package House_Management.Test_Suite is

      function Suite return AUnit.Test_Suites.Access_Test_Suite;

   end House_Management.Test_Suite;
</pre>

<p>The test suite body:

<p><a name="aunit-withs">Standard AUnit withs</a>:
<pre>
   with AUnit.Assertions; use AUnit.Assertions;
   with AUnit.Test_Cases.Registration; use AUnit.Test_Cases.Registration;
   with AUnit.Test_Cases; use AUnit.Test_Cases;
   with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
</pre>

<p><a name="test-withs">Test-specific withs</a>:
<pre>
   with ColdFrame.Project.Events.Standard.Test;
   with ColdFrame.Stubs;
   with Digital_IO.Application;
   with Digital_IO.Initialize;
   with Digital_IO.Tear_Down;
   with House_Management.Initialize;
   with House_Management.Lamp;
   with House_Management.Tear_Down;
</pre>

<p><a name="suite-body">The actual body</a>:
<pre>
   package body House_Management.Test_Suite is
</pre>

<p><a name="instantiations">Instantiations of <tt>ColdFrame.Stubs</tt> generics</a>:
<pre>
      function Get_Boolean
      is new ColdFrame.Stubs.Get_Input_Value (Boolean);
      function Get_Signal_Name
      is new ColdFrame.Stubs.Get_Input_Value (Digital_IO.Signal_Name);
</pre>

<p><a name="case-spec">A test case, for testing <i>Lamp</i> code</a>:
<pre>
      package Lamps is
         type Case_1 is new Test_Case with private;
      private
         type Case_1 is new Test_Case with null record;
         function Name (C : Case_1) return String_Access;
         procedure Register_Tests (C : in out Case_1);
         procedure Set_Up (C : in out Case_1);
         procedure Tear_Down (C : in out Case_1);
      end Lamps;
</pre>

<p><a name="case-body">The test case body</a>:
<pre>
      package body Lamps is
</pre>

<p><a name="proc-spec">A test procedure spec</a> (GNAT with style checks
enabled, <tt>-gnaty</tt>, complains if a subprogram has no spec):
<pre>
         <i>--  Check that each Lamp is connected to the correct Signal in
         --  the Digital_IO domain, in the correct sense (ie, turning the
         --  Lamp on sets the Signal to True).</i>
         procedure Turn_On (R : in out AUnit.Test_Cases.Test_Case'Class);
</pre>

<p><a name="proc-body">The test procedure body</a>:
<pre>
         procedure Turn_On (R : in out AUnit.Test_Cases.Test_Case'Class) is
            pragma Unreferenced (R);
            use type Digital_IO.Signal_Name;
         begin

            <i>--  Initialization creates a number of lamps; each one turns
            --  itself off on creation (to be tested elsewhere). However,
            --  we have to account for them; we can't just not initialize
            --  the domain, because initialization creates all the
            --  domain's singletons, initialises &#171;class&#187; attributes,
            --  and calls user {init} operations to, amongst other
            --  things, set up 'specification' instances and
            --  associations.</i>
            Assert (ColdFrame.Stubs.Number_Of_Calls
                      ("Digital_IO.Application.Set_Output") = 4,
                    "wrong number of calls");

            <i>--  Turn on the Basement lamp.</i>
            Lamp.Turn_On (Lamp.Find ((Name => Basement)));
            --  There should have been 5 calls now.
            Assert (ColdFrame.Stubs.Number_Of_Calls
                      ("Digital_IO.Application.Set_Output") = 5,
                    "wrong number of calls (a)");
            <i>--  The 5th call should have been for Lamp D ...</i>
            Assert (Get_Signal_Name ("Digital_IO.Application.Set_Output",
                                     "S",
                                     5) = Digital_IO.Lamp_D,
                    "wrong signal (a)");
            <i>--  ... and it should have been turned on.</i>
            Assert (Get_Boolean ("Digital_IO.Application.Set_Output",
                                 "To_State",
                                 5),
                    "should have been turned on (a)");

            <i>--  Repeat for the remaining Lamps.</i>
            Lamp.Turn_On (Lamp.Find ((Name => Ground_Floor)));
            Assert (ColdFrame.Stubs.Number_Of_Calls
                      ("Digital_IO.Application.Set_Output") = 6,
                    "wrong number of calls (b)");
            Assert (Get_Signal_Name ("Digital_IO.Application.Set_Output",
                                     "S",
                                     6) = Digital_IO.Lamp_C,
                    "wrong signal (b)");
            Assert (Get_Boolean ("Digital_IO.Application.Set_Output",
                                 "To_State",
                                 6),
                    "should have been turned on (b)");

            Lamp.Turn_On (Lamp.Find ((Name => First_Floor)));
            Assert (ColdFrame.Stubs.Number_Of_Calls
                      ("Digital_IO.Application.Set_Output") = 7,
                    "wrong number of calls (c)");
            Assert (Get_Signal_Name ("Digital_IO.Application.Set_Output",
                                     "S",
                                     7) = Digital_IO.Lamp_B,
                    "wrong signal (c)");
            Assert (Get_Boolean ("Digital_IO.Application.Set_Output",
                                 "To_State",
                                 7),
                    "should have been turned on (c)");

            Lamp.Turn_On (Lamp.Find ((Name => Second_Floor)));
            Assert (ColdFrame.Stubs.Number_Of_Calls
                      ("Digital_IO.Application.Set_Output") = 8,
                    "wrong number of calls (d)");
            Assert (Get_Signal_Name ("Digital_IO.Application.Set_Output",
                                     "S",
                                     8) = Digital_IO.Lamp_A,
                    "wrong signal (d)");
            Assert (Get_Boolean ("Digital_IO.Application.Set_Output",
                                 "To_State",
                                 8),
                    "should have been turned on (d)");

         end Turn_On;
</pre>

<p><a name="case-name">The test case name</a>:
<pre>
         function Name (C : Case_1) return String_Access is
            pragma Unreferenced (C);
         begin
            return new String'("Lamps.Case_1");
         end Name;
</pre>

<p><a name="registration">Test procedure registration</a> (only the one test procedure so far!):
<pre>
         procedure Register_Tests (C : in out Case_1) is
         begin
            Register_Routine
              (C,
               Turn_On'Access,
               "turn on");
         end Register_Tests;
</pre>

<p><a name="set-up">The test case set-up</a>:
<pre>
         procedure Set_Up (C : in out Case_1) is
            pragma Unreferenced (C);
            Q : constant ColdFrame.Project.Events.Event_Queue_P
              := new ColdFrame.Project.Events.Standard.Test.Event_Queue;
         begin
            ColdFrame.Stubs.Set_Up;
            Digital_IO.Initialize (Q);
            House_Management.Initialize (Q);
         end Set_Up;
</pre>

<p><a name="tear-down">The test case tear-down</a>:
<pre>
         procedure Tear_Down (C : in out Case_1) is
            pragma Unreferenced (C);
         begin
            House_Management.Tear_Down;
            Digital_IO.Tear_Down;
            ColdFrame.Stubs.Tear_Down;
         end Tear_Down;
</pre>

<p><a name="end-case">End of test case</a>:
<pre>
      end Lamps;
</pre>

<p><a name="suite-function">The test suite function</a>:
<pre>
      function Suite return AUnit.Test_Suites.Access_Test_Suite is
         Result : constant AUnit.Test_Suites.Access_Test_Suite
           := new AUnit.Test_Suites.Test_Suite;
      begin
         AUnit.Test_Suites.Add_Test (Result, new Lamps.Case_1);
         return Result;
      end Suite;
</pre>

<p><a name="end-suite">End of test suite</a>:
<pre>
   end House_Management.Test_Suite;
</pre>

<h2><a name="inspecting-event-queues">Inspecting event queues</a></h2>

<p>If your domain has state machines (and most will), you'll need to
cater for them in your testing. But it can be very difficult to manage
a unit test when the state machines are all ticking over with timed
events every 10 milliseconds!

<p>Rather than posting events to a running event queue and observing
the results, the supported way of dealing with this is via event queue
inspection; run the code, using an unstarted event queue, and check
that the appropriate events have been posted.

<p>An event queue inspector is provided
in <tt>ColdFrame.Project.Events.Standard.Inspection</tt>.

<p>There's no need to use the <tt>Test</tt> variant, because the queue
mustn't be started. To create an unstarted standard queue, say
<pre>
   Q := new ColdFrame.Project.Events.Standard.Event_Queue_Base
     (Start_Started => False,
      Priority => System.Default_Priority,
      Storage_Size => 20_000);
</pre>

<p>You can inspect the queue's self events using the functions
<pre>
   function Number_Of_Self_Events (On : Event_Queue_P) return Natural;
   function Self_Event (On : Event_Queue_P;
                        At_Index : Positive) return Event_P;
</pre>

<p>You can inspect the queue's standard events (posted to run 'now')
using the functions
<pre>
   function Number_Of_Now_Events (On : Event_Queue_P) return Natural;
   function Now_Event (On : Event_Queue_P;
                       At_Index : Positive) return Event_P;
</pre>

<p>You can inspect the queue's events posted to run after a delay
using the functions
<pre>
   function Number_Of_After_Events (On : Event_Queue_P) return Natural;
   function After_Event (On : Event_Queue_P;
                         At_Index : Positive) return Event_P;
   function How_Long_After (On : Event_Queue_P;
                            At_Index : Positive) return Duration;
</pre>

<p>You can inspect the queue's events posted to run at a later time
using the functions
<pre>
   function Number_Of_Later_Events (On : Event_Queue_P) return Natural;
   function Later_Event (On : Event_Queue_P;
                         At_Index : Positive) return Event_P;
   function When_Later (On : Event_Queue_P;
                        At_Index : Positive) return Time.Time;
</pre>
<p>(<tt>Time</tt> is the time support package used in
instantiating <tt>ColdFrame.Project.Events</tt>,
usually <tt>ColdFrame.Project.Times</tt>).

<p>All of the above access events in order of posting, and
raise <tt>Not_Found</tt> if there is no such event.

<p>Additionally, you can access the event held on a <i>Timer</i>:
<pre>
   function Event_Of (The_Timer : Timer) return Event_P; 
</pre>
<p>(returns <tt>null</tt> if there isn't one).

<p><hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>
