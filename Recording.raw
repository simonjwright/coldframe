<domain>
<extractor>extractor.ebs: cf-20060326</extractor>
<name>Recording</name>
<date>
<year>2006</year>
<month>4</month>
<day>27</day>
<time>06:04</time>
</date>
<documentation><![CDATA[ When using ColdFrame's Serialization features to support recording of the inner workings of an application, it may be necessary to limit the amount of buffering used; if your output bandwidth doesn't match your recording rate, you'll run out of memory for your application! ]]></documentation>
<classes>
<class>
<name>Recorder</name>
<visibility>PublicAccess</visibility>
<kind>NormalClass</kind>
<cardinality>1..1</cardinality>
<concurrency>Active</concurrency>
<documentation><![CDATA[ The singleton active class which manages recording.
Its task fetches Recordables from the Buffer, blocking until there is data to record; each fetched Recordable is output over the Socket. ]]></documentation>
<attributes>
<attribute>
<name>Socket</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ The socket through which data is streamed. ]]></documentation>
<type>Socket Type</type>
<initial></initial>
</attribute>
<attribute>
<name>Buff</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Manages the queue of items to be recorded. ]]></documentation>
<type>Buffer</type>
<initial></initial>
</attribute>
</attributes>
<operations>
<operation>
<name>Take Record</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Buffers a data value for recording. ]]></documentation>
<parameters>
<parameter>
<parametername>Item</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Recordable</type>
<initial></initial>
</parameter>
</parameters>
</operation>
<operation stereotype="init">
<name>Initialize</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Sets up the Socket and the Buffer. ]]></documentation>
<parameters>
</parameters>
</operation>
<operation stereotype="entry">
<name>Start</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ The task waits here until the instance is initialized. ]]></documentation>
<parameters>
</parameters>
</operation>
</operations>
<events>
</events>
</class>
<class stereotype="protected">
<name>Buffer</name>
<visibility>PrivateAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ Controls the storage of items to be recorded. ]]></documentation>
<attributes>
<attribute>
<name>Capacity</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Specifies the capacity of the buffer (number of items that can be queued for recording).
The initial value of 0 is a signal that the Buffer hasn't been initialized. ]]></documentation>
<type>Natural</type>
<initial>0</initial>
</attribute>
<attribute>
<name>Outstanding</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ The queue of items to be recorded. ]]></documentation>
<type>Queue</type>
<initial></initial>
</attribute>
<attribute>
<name>Count</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Tells how many recording attempts have been made. ]]></documentation>
<type>Natural</type>
<initial>0</initial>
</attribute>
<attribute>
<name>Dropped</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Counts the number of dropped items. ]]></documentation>
<type>Natural</type>
<initial>0</initial>
</attribute>
<attribute>
<name>Fetched</name>
<visibility>PrivateAccess</visibility>
<documentation><![CDATA[ Indicates that Fetch has been called and that we are waiting for a Done to indicate that the outstanding item can be freed. ]]></documentation>
<type>Boolean</type>
<initial>False</initial>
</attribute>
</attributes>
<operations>
<operation>
<name>Initialize</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Initializes the buffer. ]]></documentation>
<parameters>
<parameter>
<parametername>Capacity</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Positive</type>
<initial>1024</initial>
</parameter>
</parameters>
</operation>
<operation>
<name>Get Stream</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Returns an empty Memory Stream capable of holding up to Capacity bytes, or null if the Buffer is full.
The designated stream is held within the Outstanding queue. ]]></documentation>
<parameters>
<parameter>
<parametername>out S</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Stream</type>
<initial></initial>
</parameter>
<parameter>
<parametername>Capacity</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Positive</type>
<initial>1024</initial>
</parameter>
</parameters>
</operation>
<operation stereotype="entry">
<name>Fetch Stream</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Blocks until there is an item read for output to the recording medium.
After recording is complete, MUST call Done() to remove the item from the Outstanding queue. ]]></documentation>
<parameters>
<parameter>
<parametername>out S</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Stream</type>
<initial></initial>
</parameter>
</parameters>
</operation>
<operation>
<name>Done</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Called to indicate that the currently Fetched item has been dealt with. ]]></documentation>
<parameters>
</parameters>
</operation>
<operation>
<name>Statistics</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Provides information on the capacity of the Buffer, the number of items presented for recording, and the number that had to be dropped because the capacity was exceeded. ]]></documentation>
<parameters>
<parameter>
<parametername>out Capacity</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Positive</type>
<initial></initial>
</parameter>
<parameter>
<parametername>out Items</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Natural</type>
<initial></initial>
</parameter>
<parameter>
<parametername>out Dropped</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Natural</type>
<initial></initial>
</parameter>
</parameters>
</operation>
</operations>
<events>
</events>
</class>
<class stereotype="type">
<name>Queue</name>
<visibility>PrivateAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ Contains items to be recorded.
Note that what are queued are pointers to Memory Streams containing the Recordable items.
Implemented as an unbounded queue; the capacity limitation for an instance is imposed by the Buffer that contains it.
{imported = Recording Support} ]]></documentation>
<attributes>
</attributes>
<operations>
</operations>
<events>
</events>
</class>
<class stereotype="type">
<name>Stream</name>
<visibility>PrivateAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ Supports Ada streaming to memory.
Implemented as a pointer to an unconstrained Booch Components Memory Stream, so instances can be of varying sizes.

{imported = Recording Support} ]]></documentation>
<attributes>
</attributes>
<operations>
</operations>
<events>
</events>
</class>
<class stereotype="type">
<name>Socket Type</name>
<visibility>PublicAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ A TCP/IP socket, to be connected to the host that is to accept the recorded data.
{imported = GNAT.Sockets} ]]></documentation>
<attributes>
</attributes>
<operations>
</operations>
<events>
</events>
</class>
<class stereotype="public">
<name>Interface</name>
<visibility>PublicAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ The public interface to Recording. ]]></documentation>
<attributes>
</attributes>
<operations>
<operation>
<name>Take Record</name>
<visibility>PublicAccess</visibility>
<documentation><![CDATA[ Buffers a data value for recording.
If the recording buffer is full, the data will be silently dropped (though statistics on the number of dropped records may be kept and output). ]]></documentation>
<parameters>
<parameter>
<parametername>Item</parametername>
<documentation><![CDATA[  ]]></documentation>
<type>Recordable</type>
<initial></initial>
</parameter>
</parameters>
</operation>
</operations>
<events>
</events>
</class>
<class stereotype="type">
<name>Recordable</name>
<visibility>PublicAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ The base class for recordable objects.
Implemented as an Ada classwide type.
{imported = Recording Support} ]]></documentation>
<attributes>
</attributes>
<operations>
</operations>
<events>
</events>
</class>
<class stereotype="exception">
<name>Use Error</name>
<visibility>PrivateAccess</visibility>
<kind>NormalClass</kind>
<cardinality>n</cardinality>
<concurrency>Sequential</concurrency>
<documentation><![CDATA[ Raised on improper usage (for example, if a Buffer is used before it's been Initialized). ]]></documentation>
<attributes>
</attributes>
<operations>
</operations>
<events>
</events>
</class>
</classes>
<relationships>
</relationships>
</domain>
