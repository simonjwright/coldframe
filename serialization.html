<!-- $Id: serialization.html,v 6d305cf39400 2003/03/05 21:36:06 simon $ -->
<head>
<title>ColdFrame: Serialization</title>
</head>
<body bgcolor="white">
<h1>ColdFrame: Serialization</h1>

<h2>Motivation</h2>

<p>The intention of this feature is to help cope with the transfer of
data, both via network connections and also to files.

<p>Both Ada and Java include language support for serialization; Ada
in the form of <i>streams</i> (<a
href="http://adaic.org/standards/95lrm/html/RM-13-13.html">ARM95
Chapter 13</a>), Java using <tt>implements&nbsp;Serializable</tt>. So
why provide extra support?

<p>The main motivation is twofold:
<ul>

<li>a requirement to impose structure on the output data stream
(perhaps each item needs a defined header), and

<li>the need to present the transferred information ready for further
processing.

</ul>

<h2>Modelling</h2>

<p>To indicate that a &#171;type&#187; needs serialization support,
annotate it <tt>[[serializable]]</tt> (as usual, you can stereotype as
<em>&#171;type,&nbsp;serializable&#187;</em>).

<p>ColdFrame can output <a href="resources.html#xml">XML</a>
represntations of the serialized information, but it needs to be able
to convert the data values to text. This is provided for basic types
(scalars, strings, and time); for other types, you can specify a
conversion function for a &#171;type&#187; using
<tt>[[image&nbsp;:&nbsp;<i>conversion-function</i>]]</tt> in the
documentation section for the type.

<h2>Translation</h2>

<p>In the diagram,

<p><img src="serialization.png">

<p>the buff classes are what are included in the UML model, the grey
classes are what gets generated, and the yellow classes are supporting
code.

<h3>Basics</h3>

<p>The basic type is <i>T</i>, in the domain <i>Domain</i>, which is a
record type and is marked <em>&#171;serializable&#187;</em>.

<p>The generated Ada package <tt><i>Domain</i></tt> contains the type
<tt>T</tt>, which is the same as it would be without the
&#171;serializable&#187; marking.

<p>Because there is a &#171;serializable&#187; type, a child package
<tt><i>Domain</i>.Serializable</tt> is generated as well. For each
&#171;serializable&#187; type, a type and a subprogram are generated:
<pre>
   with ColdFrame.Project.Serialization;
   package <i>Domain</i>.Serializable is
      type <i>T</i> is new ColdFrame.Project.Serialization.Base with record
	 Payload : <i>Domain</i>.<i>T</i>;
      end record;
      function Image (S : <i>T</i>) return String;
   end <i>Domain</i>.Serializable;
</pre>

<p><tt>Image</tt> produces an XML rendition of the recorded value.

<p><tt>ColdFrame.Project.Serialization</tt> is expected to be an
instantiation of <tt>ColdFrame.Serialization_Signature</tt>, giving

<ul>

<li><tt>Base</tt> is a tagged type, which the Project output package
understands (it might want to add timestamp information, for example).

<li><tt>Class_Image</tt> dispatches to the generated <tt>Image</tt>
function (this is necessary to meet Ada requirements).

</ul>

<p>The provided <tt>ColdFrame.Project.Serialization</tt> is an
instantiation of <tt>ColdFrame.Serialization</tt>, which provides the
minimum needed (the <tt><i>Base</i></tt> type adds no functionality).

<h3>User-defined <i>image</i> functions</h3>

<p>For most types, ColdFrame can work out how to convert to a textual
representation for itself. This includes fundamental types such as
<tt>Boolean</tt>, user-defined scalars, strings and <tt>Time</tt>.

<p>However, this may not be possible for types imported from other
domains (it's OK for types which are visibly scalar, such as
<tt>GNAT.Sockets.Port_Type</tt>). In this case, you can specify an
image function for the type.

<p>In the diagram, <i>Foreign</i> is a renaming of type
<tt><i>Other.Domain</i>.Exported</tt>. You tell ColdFrame what image
function to use via the annotation <i><tt>[[image]]</tt></i>, in this
case
<tt>[[image:<i>Other_Domain</i>.Image_Of_Exported]]</tt>. ColdFrame
then expects to be able to call
<pre>
   function <i>[Other_Domain.]</i>Image_Of_Exported
     (Name : String;
      Value : Exported) return String;
</pre>

<p>where <tt>Name</tt> is the field name and <tt>Value</tt> is the
value to be converted to text.

<p>The output expected is discussed below.

<p><h2>Use</h2>

<h3>Demonstration</h3>

<p>A demonstration of serialization is provided in the <a
href="serialization-model.html">Serialization model</a> in the
examples subdirectory of the distribution.

<p><table>

<tr><td>The class model:
<td><a href="serialization-class-model.png"><img
src="serialization-class-model-t.png" border=1></a>

<tr><td>The state model for the Server:
<td><a href="serialization-state.png"><img
src="serialization-state-t.png" border=1></a>

<tr><td>A sequence diagram:
<td><a href="serialization-sequence.png"><img
src="serialization-sequence-t.png" border=1></a>

</table>

<p>

<p><hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>
