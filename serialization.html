<!-- $Id: serialization.html,v c9ddb46499a4 2003/09/13 16:29:09 simon $ -->
<head>
<title>ColdFrame: Serialization</title>
</head>
<body bgcolor="white">
<h1>ColdFrame: Serialization</h1>

<h2>Motivation</h2>

<p>The intention of this feature is to help cope with the transfer of
data, both via network connections and also to files.

<p>Both Ada and Java include language support for serialization; Ada
in the form of <i>streams</i> (<a
href="http://adaic.org/standards/95lrm/html/RM-13-13.html">ARM95
Chapter 13</a>), Java using <tt>implements&nbsp;Serializable</tt>. So
why provide extra support?

<p>There are two main drivers:
<ul>

<li>a typical requirement to impose structure on the output data
stream (perhaps each item needs a defined header), and

<li>the need to present the transferred information ready for further
processing.

</ul>

<h2>Modelling</h2>

<p>To indicate that a <i>&#171;type&#187;</i> needs serialization
support, annotate it <tt>[[serializable]]</tt> (as usual, you can
stereotype as
<em>&#171;type,&nbsp;serializable&#187;</em>).

<p>ColdFrame generates code which outputs <a
href="resources.html#xml">XML</a> representations of the serialized
information, but it needs to be able to convert the data values to
text.

<p>It can do this for

<ol>

<li><i>&#171;type&#187;</i>s for which you specify a conversion
function,

<li>simple (non-<i>&#171;discriminated&#187;</i>) records where each
attribute is of

<ol>

<li>a basic type (scalars, strings, or time),

<li>a <i>&#171;type&#187;</i> with a specified conversion function,

<li>a simple record type, nested recursively if required.

</ol>

</ol>

<p>There are two styles of conversion function:

<dl>

<dt><tt>[[type-image : <i>image-operation</i>]]</tt>
<dd><tt><i>image-operation</i></tt> is the name of a function taking a
value of the type and returning a string representing just the value..

<dt><tt>[[field-image : <i>image-operation</i>]]</tt>
<dd><tt><i>image-operation</i></tt> is the name of a function taking a
value of the type and a field name, returning a string representing
the value as a (set of) XML elements.

</dl>

<p><tt>[[field-image]]</tt> would be best used for imported types with
structure (for example, an array).

<p>For compatibility with ColdFrame releases up to and including
20030906, the annotation <tt>[[image]]</tt> is a shorthand for
<tt>[[field-image]]</tt>.

<h2>Translation</h2>

<p>In the diagram,

<p><a name="serialization.png"><img src="serialization.png"></a>

<p>the buff classes are what are included in the UML model, the grey
classes are what gets generated, and the yellow classes are supporting
code.

<h3>Basics</h3>

<p>The basic type is <i>T</i>, in the domain <i>Domain</i>, which is a
record type and is marked <em>&#171;serializable&#187;</em>.

<p>The generated Ada package <tt><i>Domain</i></tt> contains the type
<tt>T</tt>, which is the same as it would be without the
&#171;serializable&#187; marking.

<p>A child package <tt><i>Domain</i>.Serializable</tt> is generated as
well. For each &#171;serializable&#187; type, a type and a subprogram
are generated:
<pre>
   with ColdFrame.Project.Serialization;
   package <i>Domain</i>.Serializable is
      type <i>T</i> is new ColdFrame.Project.Serialization.Base with record
	 Payload : <i>Domain</i>.<i>T</i>;
      end record;
      function Image (S : <i>T</i>) return String;
   end <i>Domain</i>.Serializable;
</pre>

<p><tt>Image</tt> produces an XML rendition of the recorded value.

<p><tt>ColdFrame.Project.Serialization</tt> is expected to be (a
renaming of) a package containing a tagged type <tt>Base</tt>, which
the Project output package understands (it might want to add timestamp
information, for example).

<p>The provided <tt>ColdFrame.Project.Serialization</tt> is a renaming
of <tt>ColdFrame.Serialization</tt>, which provides the minimum needed
(the type <tt><i>Base</i></tt>).

<h3>Providing project serialization suport</h3>

<p>ColdFrame provides very simple support for serialization in the
package <tt>ColdFrame.Serialization</tt>. To provide your own, you
need to provide your own version of
<tt>ColdFrame.Project.Serialization</tt>; all it has to do is provide
a tagged type <tt>Base</tt> with two primitive operations:

<dl>

<dt><tt>Image</tt>
<dd>generates an XML image of the type;

<dt><tt>Base_Attribute_Image</tt>
<dd>contributes components to <tt>Image</tt> for any attributes of
your <tt>Base</tt> type.

</dl>

<p>See <tt>ColdFrame.Serialization</tt> for information on how these
should be implemented.

<h3>User-defined <i>image</i> functions</h3>

<p>For most types, ColdFrame can work out how to convert to a textual
representation for itself. This includes 

<ul>

<li>any standard type for which the <tt>'Image</tt> attribute is
available (<tt>Boolean</tt>, <tt>Integer</tt>, <tt>Duration</tt>,
<tt>Float</tt> ...)

<li>user-defined scalars (<tt><i>[[enumeration]]</i></tt>,
<tt><i>[[integer]]</i></tt>, <tt><i>[[real]]</i></tt>)

<li>strings (<tt>Text</tt> and user-defined <i><tt>[[string]]</tt></i>s)

<li><tt>Time</tt>

</ul>

<p>However, this may not be possible for types imported from other
domains (it's OK for types which are visibly scalar, such as
<tt>GNAT.Sockets.Port_Type</tt>). In this case, you can specify an
image function for the type.

<p><a href="#serialization.png">In the diagram</a>, <i>Foreign</i> is
a renaming of type
<tt><i>Other.Domain</i>.Exported</tt>. You tell ColdFrame what image
function to use via the annotation <i><tt>[[image]]</tt></i>, in this
case
<tt>[[image&nbsp;:&nbsp;<i>Other_Domain</i>.Image_Of_Exported]]</tt>.
ColdFrame then expects to be able to call
<pre>
   function <i>[Other_Domain.]</i>Image_Of_Exported
     (Value : Exported;
      Name : String) return String;
</pre>

<p>where <tt>Name</tt> is the field name and <tt>Value</tt> is the
value to be converted to text.

<p>The output expected is discussed below.

<p><h2>Use</h2>

<h3>Demonstration</h3>

<p>A demonstration of serialization is provided in the <a
href="serialization-model.html">Serialization model</a> in the
examples subdirectory of the distribution.

<p><table>

<tr><td>The class model:
<td><a href="serialization-class-model.png"><img
src="serialization-class-model-t.png" border=1></a>

<tr><td>The state model for the Server:
<td><a href="serialization-state.png"><img
src="serialization-state-t.png" border=1></a>

<tr><td>A sequence diagram:
<td><a href="serialization-sequence.png"><img
src="serialization-sequence-t.png" border=1></a>

</table>

<p>The serializable data for the demonstration (domain
<i>Serialization Demo</i>) consists of three types.

<h4>Sample A</h4>

<p><img src="sample_a.png">

<p><i>Sample A</i> shows standard types, which can be translated "as
is". The code generated in the domain package spec is
<pre>
   type Sample_A is record
      I : Integer;
      F : Float;
      B : Boolean;
      D : Duration;
      T : ColdFrame.Project.Calendar.Time;
      U : Unbounded_String;
      N : Name_String;
   end record;
</pre>

<p>(<i>Name String</i> is a bounded string, <tt>[[string:max 32]]</tt>).

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Sample_A
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Sample_A;
   end record;

   function Image (S : Sample_A) return String;
</pre>

<p>A typical result of calling Image is
<pre>
   &lt;record name="Serialization_Demo.Sample_A"&gt;
   &lt;field name="I"&gt; 42&lt;/field&gt;
   &lt;field name="F"&gt; 1.23450E-01&lt;/field&gt;
   &lt;field name="B"&gt;FALSE&lt;/field&gt;
   &lt;field name="D"&gt; 1.234500000&lt;/field&gt;
   &lt;field name="T"&gt; 1046534734.051916000&lt;/field&gt;
   &lt;field name="U"&gt;unbounded&lt;/field&gt;
   &lt;field name="N"&gt;bounded&lt;/field&gt;
   &lt;/record&gt;
</pre>

<p>(the <i>Time</i> is represented using
<tt>ColdFrame.Project.Calendar.Image</tt>; the provided version shows
the number of seconds since the POSIX epoch, 1 January 1970 00:00).

<h4>Real Time</h4>

<p><img src="real_time.png">

<p><i>Real Time</i> is a renaming of
<tt>Ada.Real_Time.Time</tt>. Because there is no <tt>'Img</tt>
function for <tt>Ada.Real_Time.Time</tt>, we have to provide our own;
this is the function <i>real time image()</i>. We tell ColdFrame that
this is the image function by
<tt>[[image&nbsp;:&nbsp;Real_Time_Image]]</tt>.

<p>The code generated in the domain package spec is
<pre>
   subtype Real_Time
   is Ada.Real_Time.Time;
   use type Real_Time;

   function Real_Time_Image
     (V : Real_Time;
      N : String)
     return String;
</pre>

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Real_Time
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Real_Time;
   end record;

   function Image (S : Real_Time) return String;
</pre>

<p>The handwritten proper body of <tt>Real_Time_Image</tt> is
<pre>
   separate (Serialization_Demo)
   function Real_Time_Image
     (V : Real_Time;
      N : String)
     return String is
      use type Ada.Real_Time.Time;
      use type Ada.Real_Time.Time_Span;
      Img : constant String :=
	Duration'Image (Ada.Real_Time.To_Duration (V - Ada.Real_Time.Time_First));
   begin
      if N'Length &gt; 0 then
	 return "&lt;field name=""" & N & """&gt;" & Img & "&lt;/field&gt;";
      else
	 return "&lt;field name=""Payload""&gt;" & Img & "&lt;/field&gt;";
      end if;
   end Real_Time_Image;
</pre>

<p>If the "field name" parameter <tt>N</tt> is empty, the image
function has been called for recording of a plain type, as in this
case, so we make up a field name. Otherwise, it's the name of the
field of this type in a record (see the next section), so it's output
verbatim.

<p>A typical result of calling <tt>Serializable.Image </tt> is
<pre>
   &lt;record name="Serialization_Demo.Real_Time"&gt;
   &lt;field name="Payload"&gt;-8176441673.395873810&lt;/field&gt;
   &lt;/record&gt;
</pre>

<h4>Recordable Real Time</h4>

<p><img src="recordable_real_time.png">

<p><i>Recordable Real Time</i> is a record with a component of a type
with an <tt>[[image]]</tt> function.

<p>The code generated in the domain package spec is
<pre>
   type Recordable_Real_Time is record
      T : Real_Time;
   end record;
</pre>

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Recordable_Real_Time
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Recordable_Real_Time;
   end record;

   function Image (S : Recordable_Real_Time) return String;
</pre>

<p>A typical result of calling Image is
<pre>
   &lt;record name="Serialization_Demo.Recordable_Real_Time"&gt;
   &lt;field name="T"&gt;-8176441673.905397810&lt;/field&gt;
   &lt;/record&gt;
</pre>

<p>Note that this time the <tt>Real_Time_Image</tt> was called with
the field name parameter set to <tt>"T"</tt>.

<h3>Creating data to be recorded</h3>

<p>Sample code for taking a <tt>Sample_A</tt> record (from the
<tt>Client</tt> program in the Serialization demonstration) is
<pre>
   Serialization.Interface.Output
     (Serialization_Demo.Serializable.Sample_A'
	(Serialization.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Serialization_Demo.Name_String_Package.To_Bounded_String
	      ("bounded"))));
</pre>

<p>This is rather more complex than, in general, it would need to
be. For a start, it would be normal to take this record from within
the domain concerned (<tt>Serialization_Demo</tt>), so we could leave
out the qualification:
<pre>
   Serialization.Interface.Output
     (Serializable.Sample_A'
	(Serialization.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Name_String_Package.To_Bounded_String ("bounded"))));
</pre>

<p>Additionally, the demonstration is a tad confusing because of the
similarity of the names. If instead of <i>Serialization</i> the
facility had been called <i>Recording</i>, it would look like
<pre>
   Recording.Interface.Output
     (Serializable.Sample_A'
	(Recording.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Name_String_Package.To_Bounded_String
	      ("bounded"))));
</pre>

<p>As a final thought, if we already had a <i>Sample A</i> value (in
say <tt>Value</tt>), it would be more like
<pre>
   Recording.Interface.Output
     (Serializable.Sample_A'
	(Recording.Serializable_Base with Payload => Value));
</pre>

<h3>Outputting the data</h3>

<p>Sample code for outputting received data (from the
<tt>Server</tt> program in the Serialization demonstration) is
<pre>
   declare
      Rec : constant ColdFrame.Project.Serialization.Base'Class :=
	ColdFrame.Project.Serialization.Base'Class'Input (Channel);
   begin
      Ada.Text_IO.Put_Line (Ada.Text_IO.Standard_Output,
			    ColdFrame.Project.Serialization.Image (Rec));
      Ada.Text_IO.Flush;
   end;
</pre>

<p>(this uses <tt>Ada.Text_IO</tt> rather than <tt>GNAT.IO</tt>
because of the need to flush the data, in case the output is
redirected).

<p>Note that this doesn't use the <tt>Serialization</tt> (or
<tt>Recording</tt>) package; instead, it uses the (renamed) real base
class, which in this case is ColdFrame's default. This ensures you
don't run the risk of pulling in lots more of the application code
than you need.

<p>However, what you <em>do</em> have to do is to <tt>with</tt> all
the <tt><i>Domain</i>.Serializable</tt> packages (if not, you'll get
an exception in <tt>'Class'Input</tt>).


<p><hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>
