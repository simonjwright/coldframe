<!-- $Id: serialization.html,v 95dc3f146594 2003/03/13 20:43:26 simon $ -->
<head>
<title>ColdFrame: Serialization</title>
</head>
<body bgcolor="white">
<h1>ColdFrame: Serialization</h1>

<h2>Motivation</h2>

<p>The intention of this feature is to help cope with the transfer of
data, both via network connections and also to files.

<p>Both Ada and Java include language support for serialization; Ada
in the form of <i>streams</i> (<a
href="http://adaic.org/standards/95lrm/html/RM-13-13.html">ARM95
Chapter 13</a>), Java using <tt>implements&nbsp;Serializable</tt>. So
why provide extra support?

<p>The main motivation is twofold:
<ul>

<li>a requirement to impose structure on the output data stream
(perhaps each item needs a defined header), and

<li>the need to present the transferred information ready for further
processing.

</ul>

<h2>Modelling</h2>

<p>To indicate that a &#171;type&#187; needs serialization support,
annotate it <tt>[[serializable]]</tt> (as usual, you can stereotype as
<em>&#171;type,&nbsp;serializable&#187;</em>).

<p>ColdFrame can output <a href="resources.html#xml">XML</a>
represntations of the serialized information, but it needs to be able
to convert the data values to text. This is provided for basic types
(scalars, strings, and time); for other types, you can specify a
conversion function for a &#171;type&#187; using
<tt>[[image&nbsp;:&nbsp;<i>conversion-function</i>]]</tt> in the
documentation section for the type.

<h2>Translation</h2>

<p>In the diagram,

<p><img src="serialization.png">

<p>the buff classes are what are included in the UML model, the grey
classes are what gets generated, and the yellow classes are supporting
code.

<h3>Basics</h3>

<p>The basic type is <i>T</i>, in the domain <i>Domain</i>, which is a
record type and is marked <em>&#171;serializable&#187;</em>.

<p>The generated Ada package <tt><i>Domain</i></tt> contains the type
<tt>T</tt>, which is the same as it would be without the
&#171;serializable&#187; marking.

<p>Because there is a &#171;serializable&#187; type, a child package
<tt><i>Domain</i>.Serializable</tt> is generated as well. For each
&#171;serializable&#187; type, a type and a subprogram are generated:
<pre>
   with ColdFrame.Project.Serialization;
   package <i>Domain</i>.Serializable is
      type <i>T</i> is new ColdFrame.Project.Serialization.Base with record
	 Payload : <i>Domain</i>.<i>T</i>;
      end record;
      function Image (S : <i>T</i>) return String;
   end <i>Domain</i>.Serializable;
</pre>

<p><tt>Image</tt> produces an XML rendition of the recorded value.

<p><tt>ColdFrame.Project.Serialization</tt> is expected to be an
instantiation of <tt>ColdFrame.Serialization_Signature</tt>, giving

<ul>

<li><tt>Base</tt> is a tagged type, which the Project output package
understands (it might want to add timestamp information, for example).

<li><tt>Class_Image</tt> dispatches to the generated <tt>Image</tt>
function (this is necessary to meet Ada requirements).

</ul>

<p>The provided <tt>ColdFrame.Project.Serialization</tt> is an
instantiation of <tt>ColdFrame.Serialization_Signature</tt> with
<tt>ColdFrame.Serialization</tt>, which provides the minimum needed
(the <tt><i>Base</i></tt> type adds no functionality).

<h3>Providing project serialization suport</h3>

<p>ColdFrame provides very simple support for serialization in the
package <tt>ColdFrame.Serialization</tt>. To provide your own, you
need to provide your own version of
<tt>ColdFrame.Project.Serialization</tt> by instantiating
<tt>ColdFrame.Serialization_Signature</tt> with your own support code.

<!-- XXX example here, after checking whether Class_Image is really
necessary! -->

<h3>User-defined <i>image</i> functions</h3>

<p>For most types, ColdFrame can work out how to convert to a textual
representation for itself. This includes fundamental types such as
<tt>Boolean</tt>, user-defined scalars, strings and <tt>Time</tt>.

<p>However, this may not be possible for types imported from other
domains (it's OK for types which are visibly scalar, such as
<tt>GNAT.Sockets.Port_Type</tt>). In this case, you can specify an
image function for the type.

<p>In the diagram, <i>Foreign</i> is a renaming of type
<tt><i>Other.Domain</i>.Exported</tt>. You tell ColdFrame what image
function to use via the annotation <i><tt>[[image]]</tt></i>, in this
case
<tt>[[image:<i>Other_Domain</i>.Image_Of_Exported]]</tt>. ColdFrame
then expects to be able to call
<pre>
   function <i>[Other_Domain.]</i>Image_Of_Exported
     (Value : Exported;
      Name : String) return String;
</pre>

<p>where <tt>Name</tt> is the field name and <tt>Value</tt> is the
value to be converted to text.

<p>The output expected is discussed below.

<p><h2>Use</h2>

<h3>Demonstration</h3>

<p>A demonstration of serialization is provided in the <a
href="serialization-model.html">Serialization model</a> in the
examples subdirectory of the distribution.

<p><table>

<tr><td>The class model:
<td><a href="serialization-class-model.png"><img
src="serialization-class-model-t.png" border=1></a>

<tr><td>The state model for the Server:
<td><a href="serialization-state.png"><img
src="serialization-state-t.png" border=1></a>

<tr><td>A sequence diagram:
<td><a href="serialization-sequence.png"><img
src="serialization-sequence-t.png" border=1></a>

</table>

<p>The serializable data for the demonstration (domain
<i>Serialization Demo</i>) consists of three types.

<h4>Sample A</h4>

<p><img src="sample_a.png">

<p><i>Sample A</i> shows standard types, which can be translated "as
is". The code generated in the domain package spec is
<pre>
   type Sample_A is record
      I : Integer;
      F : Float;
      B : Boolean;
      D : Duration;
      T : ColdFrame.Project.Calendar.Time;
      U : Unbounded_String;
      N : Name_String;
   end record;
</pre>

<p>(<i>Name String</i> is a bounded string, <tt>[[string:max 32]]</tt>).

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Sample_A
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Sample_A;
   end record;

   function Image (S : Sample_A) return String;
</pre>

<p>A typical result of calling Image is
<pre>
   &lt;record name="Serialization_Demo.Sample_A"&gt;
   &lt;field name="I"&gt; 42&lt;/field&gt;
   &lt;field name="F"&gt; 1.23450E-01&lt;/field&gt;
   &lt;field name="B"&gt;FALSE&lt;/field&gt;
   &lt;field name="D"&gt; 1.234500000&lt;/field&gt;
   &lt;field name="T"&gt; 1046534734.051916000&lt;/field&gt;
   &lt;field name="U"&gt;unbounded&lt;/field&gt;
   &lt;field name="N"&gt;bounded&lt;/field&gt;
   &lt;/record&gt;
</pre>

<p>(the <i>Time</i> is represented using
<tt>ColdFrame.Project.Calendar.Image</tt>; the provided version shows
the number of seconds since the POSIX epoch, 1 January 1970 00:00).

<h4>Real Time</h4>

<p><img src="real_time.png">

<p><i>Real Time</i> is a renaming of
<tt>Ada.Real_Time.Time</tt>. Because there is no <tt>'Img</tt>
function for <tt>Ada.Real_Time.Time</tt>, we have to provide our own;
this is the function <i>real time image()</i>. We tell ColdFrame that
this is the image function by
<tt>[[image&nbsp;:&nbsp;Real_Time_Image]]</tt>.

<p>The code generated in the domain package spec is
<pre>
   subtype Real_Time
   is Ada.Real_Time.Time;
   use type Real_Time;

   function Real_Time_Image
     (V : Real_Time;
      N : String)
     return String;
</pre>

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Real_Time
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Real_Time;
   end record;

   function Image (S : Real_Time) return String;
</pre>

<p>The handwritten proper body of <tt>Real_Time_Image</tt> is
<pre>
   separate (Serialization_Demo)
   function Real_Time_Image
     (V : Real_Time;
      N : String)
     return String is
      use type Ada.Real_Time.Time;
      use type Ada.Real_Time.Time_Span;
      Img : constant String :=
	Duration'Image (Ada.Real_Time.To_Duration (V - Ada.Real_Time.Time_First));
   begin
      if N'Length &gt; 0 then
	 return "&lt;field name=""" & N & """&gt;" & Img & "&lt;/field&gt;";
      else
	 return "&lt;field name=""Payload""&gt;" & Img & "&lt;/field&gt;";
      end if;
   end Real_Time_Image;
</pre>

<p>If the "field name" parameter <tt>N</tt> is empty, the image
function has been called for recording of a plain type, as in this
case, so we make up a field name. Otherwise, it's the name of the
field of this type in a record (see the next section), so it's output
verbatim.

<p>A typical result of calling <tt>Serializable.Image </tt> is
<pre>
   &lt;record name="Serialization_Demo.Real_Time"&gt;
   &lt;field name="Payload"&gt;-8176441673.395873810&lt;/field&gt;
   &lt;/record&gt;
</pre>

<h4>Recordable Real Time</h4>

<p><img src="recordable_real_time.png">

<p><i>Recordable Real Time</i> is a record with a component of a type
with an <tt>[[image]]</tt> function.

<p>The code generated in the domain package spec is
<pre>
   type Recordable_Real_Time is record
      T : Real_Time;
   end record;
</pre>

<p>The code generated in the <tt>Serializable</tt> child package spec
is
<pre>
   type Recordable_Real_Time
   is new ColdFrame.Project.Serialization.Base with record
      Payload : Serialization_Demo.Recordable_Real_Time;
   end record;

   function Image (S : Recordable_Real_Time) return String;
</pre>

<p>A typical result of calling Image is
<pre>
   &lt;record name="Serialization_Demo.Recordable_Real_Time"&gt;
   &lt;field name="T"&gt;-8176441673.905397810&lt;/field&gt;
   &lt;/record&gt;
</pre>

<p>Note that this time the <tt>Real_Time_Image</tt> was called with
the field name parameter set to <tt>"T"</tt>.

<h3>Creating data to be recorded</h3>

<p>Sample code for taking a <tt>Sample_A</tt> record (from the
<tt>Client</tt> program in the Serialization demonstration) is
<pre>
   Serialization.Interface.Output
     (Serialization_Demo.Serializable.Sample_A'
	(Serialization.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Serialization_Demo.Name_String_Package.To_Bounded_String
	      ("bounded"))));
</pre>

<p>This is rather more complex than, in general, it would need to
be. For a start, it would be normal to take this record from within
the domain concerned (<tt>Serialization_Demo</tt>), so we could leave
out the qualification:
<pre>
   Serialization.Interface.Output
     (Serializable.Sample_A'
	(Serialization.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Name_String_Package.To_Bounded_String ("bounded"))));
</pre>

<p>Additionally, the demonstration is a tad confusing because of the
similarity of the names. If instead of <i>Serialization</i> the
facility had been called <i>Recording</i>, it would look like
<pre>
   Recording.Interface.Output
     (Serializable.Sample_A'
	(Recording.Serializable_Base with
	   Payload =>
	   (I => 42,
	    F => 0.12345,
	    B => False,
	    D => 1.2345,
	    T => ColdFrame.Project.Calendar.Clock,
	    U => Ada.Strings.Unbounded.To_Unbounded_String ("unbounded"),
	    N => Name_String_Package.To_Bounded_String
	      ("bounded"))));
</pre>

<p>As a final thought, if we already had a <i>Sample A</i> value (in
say <tt>Value</tt>), it would be more like
<pre>
   Recording.Interface.Output
     (Serializable.Sample_A'
	(Recording.Serializable_Base with Payload => Value));
</pre>

<h3>Outputting the data</h3>

<p>Sample code for outputting received data (from the
<tt>Server</tt> program in the Serialization demonstration) is
<pre>
   declare
      Rec : constant ColdFrame.Serialization.Base'Class :=
	ColdFrame.Serialization.Base'Class'Input (Channel);
   begin
      Ada.Text_IO.Put_Line (Ada.Text_IO.Standard_Output,
			    ColdFrame.Serialization.Image (Rec));
      Ada.Text_IO.Flush;
   end;
</pre>

<p>(this uses <tt>Ada.Text_IO</tt> rather than <tt>GNAT.IO</tt>
because of the need to flush the data, in case the output is
redirected).

<p>Note that this doesn't use the <tt>Serialization</tt> (or
<tt>Recording</tt>) package; instead, it uses the real base class,
which is ColdFrame's default. This ensures you don't run the risk of
pulling in lots more of the application code than you need.


<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>
