<!-- $Id: event-use.html,v bbbeb7d333c4 2003/08/22 19:29:07 simon $ -->
<html>
<head>
<title>ColdFrame: Event use</title>
</head>
<body bgcolor="white">
<h1>ColdFrame: Event use</h1>

<h2>Event queues</h2>

<p>All code is executed in the context of some Ada task. There are
three relevant kinds of task:

<ul>

<li>the environment task (the main program),

<li>the task associated with an instance of an &#171;active&#187; class,

<li>the <i>dispatcher</i> task associated with an event queue.

</ul>

<h2>Posting an event</h2>

The typical code for posting an event <tt>Ev</tt> is
<pre>
   ColdFrame.Project.Events.Post (Ev, On => Events.Dispatcher);
</pre>

<p>Clearly <tt>Ev</tt> has to be created. If it's a class event of
type <tt>Wait</tt> to class <i>Class</i>, this would be
<pre>
   Ev : constant ColdFrame.Project.Events.Event_P
     := new Class.Wait;
</pre>

<p>whereas if it's an instance event, and we have a handle <tt>H</tt>,
it would be
<pre>
   Ev : constant ColdFrame.Project.Events.Event_P
     := new Class.Done (H);
</pre>

<p>If you need to set the payload, add a renaming:
<pre>
   Ev : constant ColdFrame.Project.Events.Event_P
     := new Class.Info;
   Payload : Message renames Class.Info (Ev.all).Payload;
</pre>

<p>(<tt>Ev.all</tt> is of type
<tt>ColdFrame.Project.Events.Event_Base'Class</tt>,

<br><tt>Class.Info (Ev.all)</tt> is a view conversion to
<tt>Class.Info</tt>,

<br>after which you can set up the payload before posting the event.)

<p>In total,
<pre>
   declare
      Ev : constant ColdFrame.Project.Events.Event_P
	:= new Class.Info;
      Payload : Message renames Class.Info (Ev.all).Payload;
   begin
      Payload := Some_Value;
      ColdFrame.Project.Events.Post (Ev, On => Events.Dispatcher);
   end;
</pre>

<h2>Locking</h2>

<p>If the task executing <a
href="event-translation.html#is_on"><tt>Is_On</tt></a> isn't the same
one as that executing the <a
href="event-modelling.html#example-model">state machine</a>, there is
a possibility that <tt>Is_On</tt> may catch the instance in an
intermediate state (in this case, the state <tt>Resetting</tt>). There
are two approaches to this problem.

<p>In the simpler, it's clear that <tt>Resetting</tt> is an
intermediate state; the <a
href="event-modelling.html#example-model">state machine</a> bounces
immediately back to <tt>On</tt> via an unguarded transition, so
<tt>Is_On</tt> could be coded
<pre>
   function Is_On (This : Handle) return Boolean is
   begin
      return This.State_Machine_State = On
               or else This.State_Machine_State = Resetting;
   end Is_On;
</pre>

<p>If the simple approach isn't good enough, it's possible to
<i>lock</i> the domain's event queue:
<pre>
   function Is_On (This : Handle) return Boolean is
      L : ColdFrame.Project.Events.Lock (Events.Dispatcher);
      pragma Warnings (Off, L);
   begin
      return This.State_Machine_State = On;
   end Is_On;
</pre>

<p>After the <tt>Lock</tt> <tt>L</tt> has been elaborated,
ColdFrame guarantees that

<ul>

<li>there are no outstanding self events on <tt>Dispatcher</tt>

<li>no further events will be dispatched by <tt>Dispatcher</tt> until
<tt>L</tt> is destroyed (by going out of scope).

</ul>

<p>Note that there's no guarantee about the relative timing of events
and locks; you could post an event and then take a lock, but the event
may or may not have been handled when the lock is achieved.

<hr>
<i>
<address>
<a href="mailto:simon@pushface.org">Simon Wright</a>
</address>
<script>
document.write("Last update: ");
document.write(document.lastModified);
</script>
</i></body>
</html>